<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>
      Phineas Help
    </title>
<style type="text/css">
<!-- 

div.indent {
  padding-left: 20px;
  font-weight: bold;
  color: brown;
}

.section {
font-weight: bold;
font-size: 18px;
}
.heading {
text-align: center;
padding-bottom: 20px;
}
/* needed for standalone tip */
.helptip {
  width: 200px; 
  color: RED;
  font:11px arial,sans-serif;
  text-decoration:none;
  text-align:left;
  float:left;
}

.helptip span.top {
  padding: 30px 8px 0;
  background: url(images/tip.gif) no-repeat top;
  display: block;
}

.helptip span.bottom {
  padding:3px 8px 15px;
  background: url(images/tip.gif) no-repeat bottom;
  display: block;
}

th {
  vertical-align: top;
}

table.utilities {
  background-color: #e5e5f5;
  border-style: solid;
  margin-left: 20px;
}

table.utilities td {
  vertical-align: top;
  border-style: solid;
	border-color: black;
	border-width: 1px;
	padding-left: 10px;
}

table.options {
  border-style: none;
	margin-left: 20px;
	margin-top: 20px;
}

table.options caption {
  font-weight: bold;
	text-align: left;
	border-bottom-style: solid;
	border-bottom-width: 1px;
}

table.options td {
  border-style: none;
  padding-right: 20px;
}
  
-->
</style>
  </head>
  <body>
    <center>
      <h1>
        <a name="contents" id="contents">Phineas Help</a>
      </h1>
    </center>
    <h3>
      Contents
    </h3>
    <ul class="section">
      <li>
        <a href="#intro">Introduction</a>
      </li>
       <li>
        <a href="#startup">Startup and Use</a>
      </li>
      <li>
        <a href="#nav">The Console and Navigation</a>
      </li>
      <li>
        <a href="#config">Configuration</a>
      </li>
      <li>
        <a href="#filters">Filters</a>
      </li>
      <li>
        <a href="#function">Functional Description</a>
      </li>
      <li>
        <a href="#security">Security</a>
      </li>
      <li>
        <a href="#certificates">Certificate Encryption</a>
      </li>
      <li>
        <a href="#whatisxml">XML - What is That?</a>
      </li>
      <li>
        <a href="#utilities">Utilities</a>
      </li>
      <li>
        <a href="#chart">PHINMS Comparison Chart</a>
      </li>
			<li>
			  <a href="console.html?howto.html">Phineas HOW TO Guide</a>
			</li>
    </ul>
    <hr>
    <div class="heading">
      <a name="intro" class="section" id=
      "intro">Introduction</a><br>
      <a href="#contents">(return to contents)</a>
    </div><b>Phineas</b> is a CDC <b>PHINMS</b> ebXML compatible
    transport system with hooks for synchronous message
    processing. If that seems like an arcane bunch of
    gibberish... well it probably is. So think about it this way.
    You have data files. You want to automate file delivery from
    one place to another. You want to simply put a file into a
    folder and have it magically appear in a specific folder
    somewhere else in the big bad internet. That's what
    <b>Phineas</b> does, but with guaranteed delivery, auditing,
    logging, security, and full HIPAA compliance.<br>
    <br>
    <hr>
    <div class="heading">
      <a name="startup" class="section" id=
      "startup">Startup and Use</a><br>
      <a href="#contents">(return to contents)</a>
    </div>
		<p>
		  <b>Phineas</b> runs in one of three modes:
			<ul>
			  <li><b>Command Window</b> runs in a command.com/cmd.exe 
				DOS window.  Use CNTL-C to force an exit or restart.</li>
				<li><b>GUI</b> runs in the service tray.  Right click the
				service tray ICON to access configuration, log, start, stop,
				or exit the service.</li>
				<li><b>MS Service</b> runs as a standard MS service.</li>
			</ul>
			All three modes accept the same set of command arguments as follows:
			<ul>
			  <li><b>-des3</b> use triple DES to encrypt configuration (default)</li>
			  <li><b>-aes123</b> use 128 bit AES to encrypt configuration</li>
			  <li><b>-aes192</b> use 192 bit AES to encrypt configuration</li>
			  <li><b>-aes256</b> use 256 bit AES to encrypt configuration</li>
			  <li><b>-c file</b> uses certificate (or key) <b>file</b>
				 to encrypt the configuration file</li>
				<li><b>-p password</b> uses <b>password</b> to encrypt the configuration
				file, or access the certificate <b>file</b> if given.</li>
				<li><b>configuration</b> uses this <b>configuration</b> on startup
				 (default <b>Phineas.xml</b>).</li>
			</ul>
    <br>
    <hr>
		<div class="heading">
      <a name="nav" class="section" id="nav">Console and
      Navigation</a><br>
      <a href="#contents">(return to contents)</a>
    </div><b>Phineas</b> features an (optional) web based
    console. While you can configure <b>Phineas</b> to run
    without a console, more often than not you will enable it.
    The console consists of a set of static HTML files and images
    that are combined with dynamic content from the application.
    You can control which content is available to the user by
    modifing these static files, as well as the console look and
    feel. This being the case, note that much of the following
    describes the "default" console, and may vary depending on
    how you customized your own <b>Phineas</b> installation.
    <p>
      In the console you'll notice a bunch of icons at the top.
      Click on these to get various functions of the console. The
      following lists possible activities.<br>
      <br>
    </p>
    <table summary="Phineas navigation">
      <tr>
        <td>
          <img src="images/queue.gif" alt="show queues">
        </td>
        <td>
          Show the Queues. <b>Phineas</b> tracks all transport
          activity in what are called queues. Basically these are
          tables with information about each file sent or
          received. The entries are color coded so that you can
          easily see issues. By selecting a record you get a
          detailed report below the queue list.
        </td>
      </tr>
      <tr>
        <td>
          <img src="images/ping.gif" alt="ping route">
        </td>
        <td>
          Send an ebXML "Ping" to selected route. Use this to
          test host and route connectivity.
        </td>
      </tr>
      <tr>
        <td width='80'>
          <img src="images/log.gif" alt="show logging">
        </td>
        <td>
          Show the log. The amount and type of information found
          in the log will vary depending on the Log Level. Beware
          that if <b>Phineas</b> has been running a long time,
          this log could be quite large!
        </td>
      </tr>
      <tr>
        <td>
          <img src="images/loop.gif" alt="show configuration">
        </td>
        <td>
          Show the configuration. <b>Phineas</b> is configured
          using a single XML configuration file. The current
          running configuration is shown. This may be different
          than the configuration being edited.
        </td>
      </tr>
      <tr>
        <td>
          <img src="images/build.gif" alt="edit configuration">
        </td>
        <td>
          Edit Configuration. This is a set of forms that you can
          use to modify a <b>Phineas</b> configuration, or export
          a CPA. Additional information on the configuration may
          be found below.
        </td>
      </tr>
      <tr>
        <td>
          <img src="images/print.gif" alt="print screen">
        </td>
        <td>
          Print the console contents. This has the same effect as
          your browser print function.
        </td>
      </tr>
      <tr>
        <td>
          <img src="images/refresh.gif" alt="refresh screen">
        </td>
        <td>
          Refresh the console. This has the same effect as your
          browser refresh function.
        </td>
      </tr>
<!--
<tr>
<td><img src="images/delete.gif" alt="delete record"></td>
<td>Delete selected item (not yet implemented).</td>
</tr>
-->
      <tr>
        <td>
          <img src="images/start.gif" alt="restart Phineas">
        </td>
        <td>
          Restarts the <b>Phineas</b> server. This will re-load
          and re-initialize the running configuration. You must
          confirm the restart. Once commenced the restart icon
          will flash green to red until the restart has
          completed.
        </td>
      </tr>
      <tr>
        <td>
          <img src="images/help.gif" alt="provide help">
        </td>
        <td>
          This help.
        </td>
      </tr>
    </table><br>
    <br>
    <hr>
    <div class="heading">
      <a name="config" class="section" id=
      "config">Configuration</a><br>
      <a href="#contents">(return to contents)</a>
    </div>
    <p>
      While <b>Phineas</b> doesn't (yet) have as many
      configuration parameters as PHINMS, there is still plenty
      of stuff to tweak. The good news is that generally speaking
      you shouldn't have to touch much (or any) of it. In fact
      one can generate a <b>Phineas</b> distribution that doesn't
      allow (easy) modification of the configuration. Unless you
      are already well versed in things like XML, HTML, network
      protocols, and so on, you might want to first study the
      sections below starting with <a href="#function">Phineas -
      A Functional Description</a>. They will provide a
      background for understanding what the various parts of the
      <b>Phineas</b> configuration are used for and how they
      affect it's function.
    </p>
    <p>
      The configuration is determined by a single XML file,
      typically located in the same folder as the executable.
      However, an alternate location may be specified on the
      command line. <b>Phineas</b> will refuse to start without a
      valid configuration file. Additionally, it may not function
      fully or correctly if miss-configured (for example, if
      logging is specified to a folder that does not exist).
    </p>
		<p>
		  The configuration may be stored in XML encrypted form in order to
			protect sensitive information.  In that case a certificate and/or
			password is included with the <b>Phineas</b> startup command.  The
			<b>xcrypt</b> utility may be used to encrypt/decrypt the configuration
			for startup use.  
		  Note that "chicken and egg" issues are always
			present with cryptographically protected data (e.g. a 'clear text'
			password is alway present somewhere in the system).  PHINMS obfuscates
			this issue by using a simple substitution cipher for it's password
			file access.  Don't be fooled.  I broke this cipher in about an hour.
			The only way to protect application passwords is via file system
			permissions (which simply passes the issue up stream to the OS :-).
		</p>	
    <p>
      A configuration GUI (Graphic User Interface) is available
      from the Web console. The configuration items, order,
      location, and so on (e.g. the "look and feel" of the GUI)
      are determined from a separate XML file. This is the only
      other <b>Phineas</b> configuration file. It is necessarily
      separate because of the "chicken and egg" problem, and
      because the GUI itself is optional. It includes brief
      specific help tips for each configuration entry. Since
      these tips are within a GUI XML file they are (like most of
      the <b>Phineas</b> functionality) user configurable!
    </p>
    <p>
      At this point things can get a bit confusing, since now we
      have two XML files associated with the configuration. For
      clarity, the rest of this document will use "configuration"
      to refer to the actual configuration data, and "GUI" to
      refer to the "meta configuration", computer talk for
      information that describes the configuration data and
      operation of the Web configuration screens. You might want
      to open the Web console and configuration files while
      studying the following descriptions to help visualize how
      everything fits together.
    </p>
    <p>
      The GUI is controlled by a small set of XML tags that
      affect the type and placement of input items for the
      configuration. The following is a list of the GUI tags and
      their usage. Please refer to <a href="#whatisxml">XML -
      What is That?</a> below for general information on XML.
    </p>
    <table summary="GUI tags" style=
    "text-align: top; padding-left: 20px;">
      <tr>
        <th>
          &lt;Config&gt;
        </th>
        <td>
          This is the "root" tag for the GUI configuration.
        </td>
      </tr>
      <tr>
        <th>
          &lt;Tab&gt;
        </th>
        <td>
          Each "page" of configuration is selected using a tab.
          All the tabs in a given level of the XML hierarchy are
          displayed together as a horizontal list. The user
          clicks on a tab to get the page associated with it.
        </td>
      </tr>
      <tr>
        <th>
          &lt;Set&gt;
        </th>
        <td>
          Groups of configuration XML items that may be repeated
          are identified as a set. A set displays and acts much
          like tabs, except that the tabs are labeled and
          organized based on a <b>&lt;Key&gt;</b>. If no key is
          present the first <b>&lt;Input&gt;</b> is assumed to be
          the key.
        </td>
      </tr>
      <tr>
        <th>
          &lt;Input&gt;
        </th>
        <td>
          The input describes one configuration data item. It has
          the following (sub) tags:<br>
          <b>&lt;Type&gt;</b> - The nature or kind of data item.
          Possible values are...
          <div style="padding:5px 40px;">
            <b>text</b> - general text<br>
            <b>number</b> - a numeric value<br>
            <b>file</b> - the name of a file<br>
            <b>dir</b> - the name of a directory (folder)<br>
            <b>select</b> - a drop down selection list<br>
            <b>password</b> - a password<br>
            <b>radio</b> - a set of radio buttons<br>
            <b>submit</b> - a submit button<br>
          </div><b>&lt;Width&gt;</b> - The optional width of the
          input field. The default width is determined by the
          <b>Type</b> above.<br>
          <b>&lt;Option&gt;</b> - items that are to be found in
          the <b>select</b> or <b>radio</b> types above.<br>
          <b>&lt;Ref&gt;</b> - a configuration item reference
          "path" that identifies items to be included in a
          <b>select</b> or <b>radio</b> types above. Note that a
          <b>Ref</b> and <b>Option</b> are mutually exclusive.
          Use one or the other, but not both in an input.<br>
          <b>&lt;Repeats&gt;</b> - If the value is "true", this
          input may be repeated, and an <b>Add</b> button will be
          included following the last repeated input.<br>
        </td>
      </tr>
      <tr>
        <th>
          &lt;Tags&gt;
        </th>
        <td>
          The tags are a space delimited list of XML tags used to
          identify data within a given GUI section. Tags are
          combined accross the hierarchy of the GUI XML to form
          the complete "path" to a configuration data item
        </td>
      </tr>
      <tr>
        <th>
          &lt;Name&gt;
        </th>
        <td>
          GUI items are identified to the user by this Name. It
          can be applied to a tab, an input (where it is used as
          the prompt), or a set description.
        </td>
      </tr>
      <tr>
        <th>
          &lt;Help&gt;
        </th>
        <td>
          <div style="float:left;">
            Use a Help tag to associate "bubble" help tips with
            GUI items.
          </div>
          <div class="helptip">
            <span class="top">You can author your own help tip
            text like this by modifying the GUI XML file
            (normally "console/config.xml"). Look for
            &lt;Help&gt; tags!</span> <span class=
            "bottom"> </span>
          </div>
        </td>
      </tr>
    </table>
    <p>
      <b>Phineas</b> configuration consists of a set of shared
      common data items followed by various feature sections. In
      the GUI each of these item sets are selected using tabs,
      which correspond to sections within the actual XML file.
      Similarly, features that can repeat (like a <b>Route</b>)
      are each given their own GUI tab as well as a "NEW" tab for
      adding additional features. The following is a list of
      those tabs, XML tags, and item descriptions as found in the
      GUI. This is the same information provided within the GUI
      as help tips.
    </p>
    <center>
      <br>
      <iframe src="chelp.html" width="95%" height="500">Itemized
      list of configuration items</iframe>
    </center><br>
    <hr>
    <div class="heading">
      <a name="filters" class="section" id="filters">Filters</a><br>
      <a href="#contents">(return to contents)</a>
    </div>
    <p>
		  A <b>filter</b> is a program which is used to act on or modify
		  data.  The concept of a filter has it's origins in
			the early history of UNIX.  The filter
			reads data from the standard input (normally the keyboard), 
			alters or acts on that data in some way, and then writes the result
			to the standard output (normally the screen).  Such a program
			could be thought of as "filtering" the data.  Couple this with the
			ability to "redirect" standard input and output to either files
			or other programs and you suddenly have a very powerful set of 
			tools for manipulating data.
	  </p>
		<p>
		  <b>Phineas</b> applies this concept to its messaging transport.
			Both senders and receivers may be configured to modify data "on
			the fly" by plugging in a filter.  The filter can be any program
			that does not require user interaction (obviously, you don't want
			to sit and wait for messages to come and go, just to interact with
			the message filter). 
		</p>
		<p>
		  For example lets consider the scenario, where a laboratory is
			providing reportable conditions (ELR) in a CSV (comma delimited)
			format.  One could develop a stand-alone program that would read
			such data and convert it to HL7 v2.5.1 to meet meaninful use
			requirements.  This program could be inserted either into the
			sender or receiver filter to automate this data transformation.			
		</p>
		<p>
		 For details on configuring a filter please
			see the <a href="console.html?howto.html">Phineas HOW TO Guide</a>.
		</p>
    <hr>
    <div class="heading">
      <a name="function" class="section" id="function">Phineas -
      A Functional Description</a><br>
      <a href="#contents">(return to contents)</a>
    </div>
    <p>
      At it's core, <b>Phineas</b> is designed to be a PHINMS
      compatible transport application, so we'll begin by looking
      at some of the features and functions provided by PHINMS.
      Once you understand what a function does, the
      implementation and configuration will hopefully make more
      sense. Additionally, issues or problems should be easier to
      resolve, since you will be able to relate them to specific
      features.
    </p>
    <p>
      Lets start at the "bottom" with transport. The primary
      function of PHINMS is of course to get some data (a
      "payload") from one location on the internet to another.
      There are a lot "protocols" that do this including familiar
      ones like SMTP (for email) and (S)FTP (for files). Think of
      a protocol as a kind of foreign language. Each has its own
      syntax and grammar used for communication. PHINMS uses the
      HTTP(S) protocol, which is generally associated with Web
      site access. It is a request/response protocol, where the
      client (typically your web browser like IE or Mozilla)
      sends a request to a web server, which in turn responds
      with a Web page that you can look and marvel at. When using
      HTTPS the protocol is encrypted (more on that later).
    </p>
    <p>
      The folks who came up with HTTP were smart enough to not
      limit it to Web, or HTML content. That makes it possible
      for you to get pictures, spreadsheets, and the like from a
      Web site. That brings us to the second aspect of transport,
      the "content type". PHINMS uses something called ebXML to
      embed additional functionality into the HTTP protocol. Each
      request and response uses this content encoding scheme or
      "type" to communicate and implement a set of "meta data"
      and security features. "Meta data" is a fancy way of
      saying, "Here is something you might want to know about the
      payload I'm sending", for example it's size, where it came
      from, or it's file name.
    </p>
    <p>
      The second basic function of PHINMS is to formally track
      and record all of its transport activity. This provides an
      audit trail for PHI (Personal Health Information) data.
      This is a distinct and unique function not found in other
      transport like FTP. It also serves as mechanism to control
      and monitor the transport. In PHINMS these records exist as
      "Queues", where both the sender and receiver keeps
      information about each transfer (attempt). Most of the meta
      data mentioned above can be found in the Queues. They
      normally exist as tables within a database, but note that
      <b>Phineas</b> includes a light weight file implementation.
    </p>
    <p>
      If PHINMS is going to use Queues to control and monitor
      transport, it needs some way to get things rolling. After
      all, data isn't just going to magically appear in a Queue.
      One way is to provide an interactive dialog with the user
      that allows them to "queue" or identify a file for
      transport. However, most of us would rather automate this
      process. PHINMS provides a "Folder Polling" function that
      "Maps" files in a folder to a specific Queue. When a file
      appears in that folder, it is automatically entered in a
      queue for transport. That's almost magic!
    </p>
    <p>
      There is other stuff we need to know in order to transport
      a file though. We need to know where to send it. PHINMS
      calls this end point a "Route" which is identified in the
      "Map". We also need to communicate exactly how the Route
      should deal with or process the file. A "Service" and
      "Action" are indicated in the Map for this purpose, as well
      as optional "Arguments". This allows a receiver (Route) to
      manage multiple payload types (for example to separate
      Influenza payloads from TB).
    </p>
    <p>
      That brings us the the third major function of PHINMS which
      is to provide security. Security (encryption,
      authentication, and authorization) is not only desirable,
      but required for PHI! Both the Route and the Map include
      information on how to manage various security aspects of
      the transport. There are folks out there that devote their
      entire career to just one single aspect of security. It's
      pretty heady stuff, which is why it causes so many people
      problems. Security functionality and features are big and
      complex enough to warrant their own section below!
    </p>
    <p>
      That's not a comprehensive list of PHINMS functions, but
      covers the big stuff. <b>Phineas</b> doesn't implement all
      of the PHINMS functions, but does provide a few that PHINMS
      doesn't. Most notable are data filtering and user
      configuration. Data filtering is way for either senders or
      receivers to automatically process payloads through
      external programs. For example, you might have a program
      that converts an HL7 message to a spreadsheet. You can
      insert this program as a Phineas filter and have HL7
      (payload) files automatically stored or sent as
      spreadsheets.
    </p>
    <p>
      Additionally, user configuration, both at build and run
      time, allows you to control the look, feel, and
      functionality of <b>Phineas</b>. Another nice feature is
      that the folder Map respects wild cards when selecting
      files for transport. That allows you to use a single folder
      for multiple Maps. For example, you could have an ELR map
      that only sends files with ".obx" extensions and a second
      map for HIV data that only send files with ".hiv"
      extensions.
    </p>
    <hr>
    <div class="heading">
      <a name="security" class="section" id=
      "security">Security</a><br>
      <a href="#contents">(return to contents)</a>
    </div>
    <p>
      PHINMS security is implemented on two levels: in the
      protocol (HTTPS) and within the application (ebXML). While
      distinct, there are many similarities between the two, and
      both are based on x509 certificate encryption techniques.
      As a result it is useful to understand the nature and
      function of a x509 certificate, so you might want to read
      the section on <a href="#certificates">Certificate
      Encryption</a> below.
    </p>
    <p>
      Protocol level security is implemented with information
      from a PHINMS "Route" for the sender, and in the HTTP
      server of a receiver. For the latter this is generally a
      "proxy" of some sort, and each has it's own implementation
      for the same basic protocols. A sender specifies HTTPS in
      the Route for an encrypted connection, in which case the
      receiver usually needs to present a valid certificate
      signed by an entry in the sender's "Certificate Authority"
      (in <b>Phineas</b> this is optional).
    </p>
    <p>
      The receiver may also require the sender authenticate using
      one of several protocols. <b>Phineas</b> currently supports
      SSL x509 client certificate authentication and HTTP header
      based "basic authentication". In x509 protocol the receiver
      challenges the sender who replies with a certificate of its
      own. All this is part of standard "SSL Negotiations" and is
      more or less transparent to the PHINMS application. In
      "basic authentication" the receiver requires the sender to
      include authentication information in the HTTP headers.
      Since this information is not encrypted, this
      authentication method should only be used with HTTPS (SSL)
      connections. Generally "basic authentication" is handled by
      the HTTP server, but it may be implemented at the
      application level (as happens to be the case with
      <b>Phineas</b>).
    </p>
    <p>
      The second ebXML level of security operates in a similar
      way, but is implemented within the PHINMS application. The
      sender keeps security information in each "Map". This
      includes whether the payload is to be encrypted, and if so
      the location of the certificate used. The sender may also
      "sign" the payload as an authentication measure. This also
      adds something called "non-repudiation", the concept that a
      sender can't deny sending a given message. The receiver
      must have the decryption (certificate) key and may
      optionally check signed messages for authenticity.
    </p>
    <p>
      As you can see, PHINMS has the ability to "double encrypt
      and authenticate" each payload, making it very secure.
      Additionally the lower ebXML security layer makes it
      possible to securely use intermediates in the transport
      (e.g. agents who are responsible for receiving or sending
      data, but who can NOT read the contents). This important
      attribute makes PHINMS RNR (Route Not Read) hubs possible.
    </p>
    <p>
      There are obviously additional security measure that may
      exist outside PHINMS including firewalls, private and/or
      secured subnets, etc. The thing to remember is that
      generally speaking, each side must agree upon the type and
      nature of security in use, and include or exchange enough
      information to enable the cryptography and insure mutual
      trust (generally in the form of certificates).
    </p>
    <hr>
    <div class="heading">
      <a name="certificates" class="section" id=
      "certificates">Certificates and Encryption</a><br>
      <a href="#contents">(return to contents)</a>
    </div>
    <p>
      The internet is the biggest "party line" ever created. Just
      as in the early days of telephony, when you could hear your
      neighbors conversions, so also can one now listen in on
      internet messages. As a result when you need internet
      privacy, the only way to get it is to converse in a secret
      code (encrypt your message). Similarly, when you "call
      someone up" you may need to determine they are who you
      think they are and vice versa (authenticate). The x509
      certificate and associated functions were designed to do
      just that.
    </p>
    <p>
      Lets first discuss encryption. For certificate purposes
      there are basically two types: symmetric and asymmetric.
      With symmetric encryption a single shared but secret "key"
      is known by both sides of the conversation, and is used to
      both encrypt and decrypt the message. That poses a problem.
      How do you exchange this secret key? You could use some
      other media (telephone, or US mail) but that would be
      cumbersome.
    </p>
    <p>
      However, some pretty smart people came up with asymmetric
      encryption, where you encrypt a message with one key, but
      need a second different key to decrypt the message. The
      encryption key can be "public". Anyone can use it to send
      you a secret message. You keep the decryption key "private"
      so that only you can decrypt a secret message.
      Unfortunately, such encryption is inherently slow, and only
      works well when the data to encrypt is the same size as the
      key.
    </p>
    <p>
      So we combine the two type. We generate a random symmetric
      key, use that to encrypt our data, then encrypt that key
      with the public asymmetric key and send the whole mess off.
      Decryption is the opposite. Use the "private" asymmetric
      key to decrypt the secret symmetric key, which is then used
      to decrypt our message. Since the symmetric key is
      generated as needed, we only have to store the asymmetric
      keys. We give the public one to the sender and keep the
      private one to ourself. The certificate is a convenient
      place to store and exchange public keys.
    </p>
    <p>
      OK, so we can now hand out a "public" key as a certificate
      that allows us to have private conversation with anyone.
      How do we know who we are talking to? We most likely want
      to "authenticate" each other. One thing we can do is put
      our name in the certificate. In x509 speak thats called a
      "DN" or "distinguished name", a unique identifier. And we
      can make sure that no one can easily change the name on a
      certificate by including a "digest", a calculated value
      that only matches our name and keys.
    </p>
    <p>
      But that still may not be enough. If we are total
      strangers, we may want someone we know in common to vouch
      for us. Otherwise you could forge a name on a (new)
      certificate, pretending to be someone you are not. To
      address this we have a mutual acquaintance "sign" our
      certificate. Such a signer is called a "Certificate
      Authority" or "CA", and we keep our own private list of
      them.
    </p>
    <p>
      There is other useful stuff we record with our certificate
      like the date it was issued, how long it is good for, and
      esoteric information about how to confirm the digest and
      use the public key. When we authenticate someone we use as
      much (or little) of this information as we like. In fact we
      can simply not authenticate at all which is exactly what
      most public Web servers do for HTTPS (as opposed to
      browsers, where unauthenticated Web sites usually pop up a
      warning message to the user).
    </p>
    <p>
      A lot of confusion concerning certificates arise from the
      various formats used to store essentially the same
      information for certificates and private keys. For the most
      part it is reasonably easy to convert between them, once
      you understand that it is "form" and not "function" that is
      the issue. Here is a brief list of some formats you might
      run into.
    </p>
    <ul>
      <li>
        <b>PEM</b>-base64 encoded. You can embed these right in
        your email, since they are made up of "printable"
        characters. Often these certificates will have ".crt"
        extensions. While the private key may be stored in the
        same file, it is separately encoded from the certificate.
        Multiple certificates may be included in the same file to
        create a certificate authority.
      </li>
      <li>
        <b>DER</b>-binary encoded. These are essentially the same
        a PEM certificates/keys, but in a binary format. That
        makes them smaller and load slightly faster, but are
        harder to exchange. Private keys are kept in separate
        files, and you can't combine multiple certificates or
        keys into a single file.
      </li>
      <li>
        <b>PKCS12</b>-encrypted certificate store. This is a
        binary encrypted file holding both private keys and
        certificates. The typical MS extension for these files is
        ".pfx".
      </li>
      <li>
        <b>Keystore</b>-Java encoded. These are similar to the
        PKCS12 format in function, but accessed from the JVM
        (Java Virtual Machine) and include the ability to "alias"
        certificate names. The standard JVM certificate authority
        is typically named "cacerts".
      </li>
    </ul>
    <hr>
    <div class="heading">
      <a name="whatisxml" class="section" id="whatisxml">XML -
      What is that?</a><br>
      <a href="#contents">(return to contents)</a>
    </div>
    <p>
      There are a lot of references to XML (EXtensible Markup
      Language) above and you might be wondering, "What the heck
      is that?". There are a many good Web resources that can
      explain it better that here, but for completeness the
      following is a very brief introduction.
    </p>
    <p>
      If you have authored any HTML, you have already used a
      specialized form of XML. Like HTML, XML consists of "tags"
      and text. A tag has a name and optional attributes surround
      by angle brackets, for example...
    </p>
    <div class="indent">
      &lt;SomeTagName AnAttribute="value"&gt;
    </div>
    <p>
      A tag may be self contained (self closing) as in...
    </p>
    <div class="indent">
      &lt;SelfClosingTagName/&gt;
    </div>
    <p>
      or it may be paired as open and closing tags with (data)
      text in between...
    </p>
    <div class="indent">
      &lt;TagName&gt;Some text&lt;/TagName&gt;
    </div>
    <p>
      Tags are normally hiearchial in nature, and there should
      only be one tag at the outer most level, referred to as the
      XML "root". Tags may repeat and nest to whatever level is
      desired, and should always "close" (e.g. be matched pairs
      or self closing)...
    </p>
    <div class="indent">
      &lt;RootTag&gt;
      <div class="indent">
        &lt;InnerTag&gt;some data&lt;/InnerTag&gt;
      </div>
      <div class="indent">
        &lt;InnerTag&gt;other data&lt;/InnerTag&gt;
      </div>
      <div class="indent">
        &lt;InnerTag&gt;
        <div class="indent">
          &lt;NestedTag&gt;nested data&lt;/NestedTag&gt;
        </div>&lt;/InnerTag&gt;
      </div>&lt;/RootTag&gt;
    </div>
    <p>
      Basic XML is simply a way to organize and identify data.
      Since Phineas had to support ebXML (Enterprise Business
      XML) for the transport, it made sense to use XML for
      configuration as well (rather that create yet another data
      format). Plus, since XML is a simple ASCII file, you can
      use text based processing programs (like your favorite
      editor!) to view, maintain, and modify it. That should be
      about all that you HAVE to know to directly modify Phineas
      configurations.
    </p>
    <hr>
    <div class="heading">
      <a name="utilities" class="section" id=
      "utilities">Utilities</a><br>
      <a href="#contents">(return to contents)</a>
    </div>
    <p>
      <b>Phineas</b> includes a small set of utilities to help
      configure, maintain, and support the service. They can
      roughly be divided into two classes: scripts and binarys.
      Note that some utilities are only useful for specific
      installations (see descriptions below).
    </p>
    <p>
      A description of the scripts follows:
    </p>
    <table summary="script utilities" class="utilities">
      <tr>
        <td>
          <h3>
            accessdb.vbs
          </h3>
        </td>
        <td>
          This creates a fresh empty Access dB in the queues folder
          named "phineas.mdb". Creates a transport and receiver queue
          as well as a file DSN (note <b>Phineas</b> does not
          create nor require registry based DSN's for ODBC
          connections).
        </td>
      </tr>
      <tr>
        <td>
          <h3>
            addservice.bat
          </h3>
        </td>
        <td>
          Add <b>Phineas</b> as an MS Service. It first checks to
          make sure it is not already registered. Then starts it.
        </td>
      </tr>
      <tr>
        <td>
          <h3>
            delservice.bat
          </h3>
        </td>
        <td>
          This checks to see if <b>Phineas</b> is installed as an MS
          Service. If so it stops <b>Phineas</b> and removes the service.
          Note the MS OS requires a reboot to complete this
          operation.
        </td>
      </tr>
    </table>
    <p>
      For the most part the binary utilities are simply
      "wrappers" for parts of the <b>Phineas</b> code
      functionality that allow you to script operations
      independent of the server. You'll find these utilities in a
      typical installation "bin" folder. A description of the
      binary utilities follows:
    </p>
    <table summary="binary utilities"  class="utilities">
      <tr>
        <td>
          <h3>
            xmlb.exe
          </h3>
        </td>
        <td>
          This is an XML beautifier. It places each tag on a
          separate line with a default indent of 2 spaces for
          each embedded tag.
          <table summary="options" class="options">
					  <caption>Options</caption>
            <tr>
              <td>
                -#
              </td>
              <td>
                set the indent to # spaces
              </td>
            </tr>
            <tr>
              <td>
                -o outfile
              </td>
              <td>
                write out to <b>outfile</b> (defaults to stdout)
              </td>
            </tr>
            <tr>
              <td>
                infile
              </td>
              <td>
                read input from <b>infile</b> (defaults to stdin)
              </td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <h3>
            xcrypt.exe
          </h3>
        </td>
        <td>
				  This utility provides a mechanism to encrypt or decrypt XML
					encoded payload envelopes.  When a PHINMS receiver get a message
					which is encrypted with a DN (distinguished name) that does not
					match the certificate specified for decryption, it stores the
					entire payload envelope to disk.  The envelope is in XML format
					and includes information on how to select decryption keys (based
					on the DN) and which symetric algorithm to use for decryption
					(normally triple-DES).  A keyfile and/or password must be specified.
					This utility may be used to encrypt/decrypt the <b>Phineas</b>
					configuration file.
          <table summary="options" class="options">
					  <caption>Options</caption>
            <tr>
              <td>
                -des3
              </td>
              <td>
                Triple DES encryption (default)
              </td>
            </tr>
            <tr>
              <td>
                -aes128
              </td>
              <td>
                128 bit AES encryption
              </td>
            </tr>
            <tr>
              <td>
                -aes192
              </td>
              <td>
                192 bit AES encryption
              </td>
            </tr>
            <tr>
              <td>
                -aes256
              </td>
              <td>
               256 bit AES encryption
              </td>
            </tr>
            <tr>
              <td>
                -e
              </td>
              <td>
                encrypt (default is to decrypt)
              </td>
            </tr>
            <tr>
              <td>
                -l log
              </td>
              <td>
                write status to <b>log</b> (defaults to stdout)
              </td>
            </tr>
            <tr>
              <td>
                -L level
              </td>
              <td>
                set logging <b>level</b> (defaults to INFO)
              </td>
            </tr>
            <tr>
              <td>
                -p password
              </td>
              <td>
                use this <b>password</b> for the keyfile or encryption
              </td>
            </tr>
            <tr>
              <td>
                -d dn
              </td>
              <td>
                the distinguished name is <b>dn</b>
              </td>
            </tr>
            <tr>
              <td>
                -o outfile
              </td>
              <td>
                write results to <b>outfile</b> (defaults to
                stdout)
              </td>
            </tr>
            <tr>
              <td>
                -i infile
              </td>
              <td>
                read data from <b>infile</b> (defaults to stdin)
              </td>
            </tr>
            <tr>
              <td>
                keyfile
              </td>
              <td>
                get cryptography key from <b>keyfile</b>
                which can be a PEM, DER, or PKCS12
                encoded certificate, or a binary, hex, or base64
								encoded symetric key (in which case the key must be
								appropriate for the designated algorithm).
              </td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <h3>
            cpa.exe
          </h3>
        </td>
        <td>
          Generate a sender's CPA (communication protocol
          aggreement) file for export to a PHINMS receiver.
          <table summary="options" class="options">
					  <caption>Options</caption>
            <tr>
              <td>
                -#
              </td>
              <td>
                export the route # (first route)
              </td>
            </tr>
            <tr>
              <td>
                configuration
              </td>
              <td>
                use this sender <b>configuration</b> file
              </td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <h3>
            chelp.exe
          </h3>
        </td>
        <td>
          Generates console configuration help, based on the
          console configuration file. This allows you to only
          show help for those features available in a given
          installation.
          <table summary="options" class="options">
					  <caption>Options</caption>
            <tr>
              <td>
                -o outfile
              </td>
              <td>
                write console help to <b>outfile</b> (defaults to
                console\chelp.html)
              </td>
            </tr>
            <tr>
              <td>
                infile
              </td>
              <td>
                read console configuration from <b>infile</b>
                (defaults to console\config.xml)
              </td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <h3>
            psetup.exe
          </h3>
        </td>
        <td>
          This will generate an installation configuration.  It normally
					is only run from the installer.
          <table summary="options" class="options">
					  <caption>Options</caption>
            <tr>
              <td>
                -i path
              </td>
              <td>
                set the installation folder <b>path</b>
              </td>
            </tr>
            <tr>
              <td>
                -o organization
              </td>
              <td>
                set the <b>organization</b> name
              </td>
            </tr>
            <tr>
              <td>
                -P port
              </td>
              <td>
                set the http(s) <b>port</b>
              </td>
            </tr>
            <tr>
              <td>
                -P port
              </td>
              <td>
                set the http(s) <b>port</b>
              </td>
            </tr>
            <tr>
              <td>
                -p partyID
              </td>
              <td>
                set the <b>partyID</b>
              </td>
            </tr>
            <tr>
              <td>
                -t template
              </td>
              <td>
                use this file for the configuration
                <b>template</b>
              </td>
            </tr>
            <tr>
              <td>
                -r
              </td>
              <td>
                receiver only configuration
              </td>
            </tr>
            <tr>
              <td>
                -s
              </td>
              <td>
                sender only configuration
              </td>
            </tr>
            <tr>
              <td>
                outfile
              </td>
              <td>
                write configuration to <b>outfile</b>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
    <hr>
    <div class="heading">
      <a name="chart" class="section" id="chart">Phineas/PHINMS
      Comparison Chart</a><br>
      <a href="#contents">(return to contents)</a>
    </div>
    <table summary="Phineas/PHINMS Comparison Chart" border="1">
      <col width="20%">
      <col width="20%">
      <col width="20%">
      <thead style="background: #99bbff">
        <tr>
          <th>
            Feature
          </th>
          <th>
            Phineas
          </th>
          <th>
            PHINMS 2.8.01
          </th>
        </tr>
      </thead>
      <tbody style="background: #cceeff">
        <tr>
          <td>
            Platform
          </td>
          <td>
            MS
          </td>
          <td>
            MS and *NIX
          </td>
        </tr>
        <tr>
          <td>
            Language
          </td>
          <td>
            ANSI C
          </td>
          <td>
            Java
          </td>
        </tr>
        <tr>
          <td>
            License
          </td>
          <td>
            open source Apache
          </td>
          <td>
            proprietary
          </td>
        </tr>
        <tr>
          <td>
            Server
          </td>
          <td>
            embedded (stand alone), ISAPI*, CGI*
          </td>
          <td>
            Tomcat
          </td>
        </tr>
        <tr>
          <td>
            Execution Modes
          </td>
          <td>
            Transceiver, Sender, or Receiver as Service, Tray
            GUI, DOS Window, or Web server plugin*
          </td>
          <td>
            Transceiver as Service
          </td>
        </tr>
        <tr>
          <td>
            Disk Foot Print
          </td>
          <td>
            2MB
          </td>
          <td>
            500MB (recommended)
          </td>
        </tr>
        <tr>
          <td>
            Memory Foot Print
          </td>
          <td>
            10MB
          </td>
          <td>
            250MB (1GB recommended)
          </td>
        </tr>
        <tr>
          <td>
            Queue support
          </td>
          <td>
            file based, ODBC
          </td>
          <td>
            JDBC
          </td>
        </tr>
        <tr>
          <td>
            Console
          </td>
          <td>
            web based
          </td>
          <td>
            Java application (stand alone)
          </td>
        </tr>
        <tr>
          <td>
            Configuration GUI
          </td>
          <td>
            user configurable, optional
          </td>
          <td>
            fixed
          </td>
        </tr>
        <tr>
          <td>
            Number of Config Files
          </td>
          <td>
            1 required, 1 optional
          </td>
          <td>
            12+
          </td>
        </tr>
        <tr>
          <td>
            Folder Polling
          </td>
          <td>
            yes, with file pattern matching
          </td>
          <td>
            yes
          </td>
        </tr>
        <tr>
          <td>
            Queue Polling
          </td>
          <td>
            yes
          </td>
          <td>
            yes
          </td>
        </tr>
        <tr>
          <td>
            Ping
          </td>
          <td>
            yes
          </td>
          <td>
            yes
          </td>
        </tr>
        <tr>
          <td>
            Route Authentication
          </td>
          <td>
            basic, clientcert
          </td>
          <td>
            basic, custom, netegrity, clientcert
          </td>
        </tr>
        <tr>
          <td>
            Payload Encryption
          </td>
          <td>
            yes
          </td>
          <td>
            yes
          </td>
        </tr>
        <tr>
          <td>
            Certificate formats
          </td>
          <td>
            DER, PEM, or PKCS12
          </td>
          <td>
            DER, PEM, PKCS12, or Java keystores
          </td>
        </tr>
        <tr>
          <td>
            LDAP support
          </td>
          <td>
            no*
          </td>
          <td>
            yes
          </td>
        </tr>
        <tr>
          <td>
            Multi-block transport
          </td>
          <td>
            no*
          </td>
          <td>
            yes
          </td>
        </tr>
        <tr>
          <td>
            Digital Signatures
          </td>
          <td>
            no*
          </td>
          <td>
            yes
          </td>
        </tr>
        <tr>
          <td>
            Route Not Read
          </td>
          <td>
            no*
          </td>
          <td>
            yes
          </td>
        </tr>
        <tr>
          <td>
            Configurable Feature Set
          </td>
          <td>
            yes
          </td>
          <td>
            no
          </td>
        </tr>
        <tr>
          <td>
            Transport Filters
          </td>
          <td>
            yes
          </td>
          <td>
            no
          </td>
        </tr>
        <tr>
          <td>
            Resend
          </td>
          <td>
            yes
          </td>
          <td>
            yes
          </td>
        </tr>
        <tr>
          <td>
            Delete
          </td>
          <td>
            yes
          </td>
          <td>
            yes
          </td>
        </tr>
        <tr>
          <td>
            Queue message from console
          </td>
          <td>
            no
          </td>
          <td>
            yes
          </td>
        </tr>
      </tbody>
    </table>
    <p>
      * planned, but not yet implemented
    </p><br>
    <a href="#contents">(return to contents)</a>
  </body>
</html>
